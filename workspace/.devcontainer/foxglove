#!/usr/bin/env bash

# Exit immediately if a command exits with a non-zero status.
set -e

# --- Script Configuration ---
# Default port for the Foxglove WebSocket server.
DEFAULT_PORT=8765
# Global variable to hold the bridge process ID for cleanup.
BRIDGE_PID=

# --- Help Message ---
# Displays usage information for the script.
show_help() {
  cat << EOF
Usage: $(basename "$0") [-h|--help] [--port PORT] [ros_launch_args...]

Launches the Foxglove bridge and lichtblick client.

This script first terminates any existing Foxglove bridge instances. It then launches a new bridge and the lichtblick client.
ROS 2 workspaces must be sourced before running this script.

OPTIONS:
  -h, --help        Show this help message and exit.
  --port PORT       Specify the WebSocket port for the bridge. Defaults to ${DEFAULT_PORT}.

EXAMPLES:
  # Launch with default settings
  $(basename "$0")

  # Launch on a custom port
  $(basename "$0") --port 8766

  # Pass arguments to 'ros2 launch'
  $(basename "$0") use_sim_time:=True

  # Combine a custom port and ROS arguments
  $(basename "$0") --port 8766 use_sim_time:=True
EOF
}

# --- Cleanup Function ---
# Ensures the background foxglove_bridge process is terminated when the script exits.
cleanup() {
  # Check if the BRIDGE_PID variable is set and refers to a running process
  if [[ -n "$BRIDGE_PID" && -e /proc/"$BRIDGE_PID" ]]; then
    echo -e "\nShutting down Foxglove bridge (PID: ${BRIDGE_PID})..."
    # Kill the process and suppress output
    kill "$BRIDGE_PID" > /dev/null 2>&1
  fi
}

# --- Main Logic ---
main() {
  local port="${DEFAULT_PORT}"
  # Use an array to safely store ROS launch arguments
  local ros_args=()

  # --- Argument Parsing ---
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      --port)
        # Check if the port number is a valid integer in the correct range
        if [[ -n "$2" && "$2" =~ ^[0-9]+$ && "$2" -ge 1024 && "$2" -le 65535 ]]; then
          port="$2"
          shift 2 # Consume '--port' and its value
        else
          echo "Error: --port requires a valid port number (1024-65535)." >&2
          exit 1
        fi
        ;;
      *)
        # Assume all other arguments are for ros2 launch
        ros_args+=("$1")
        shift
        ;;
    esac
  done

  # --- Port Availability Check ---
  echo "Checking if port ${port} is available..."
  if ss -tuln | grep -q ":${port}\b"; then
    echo "Error: Port ${port} is already in use." >&2
    echo "Please free the port or use the --port option to specify another." >&2
    # You can optionally show which process is using the port if 'lsof' is available
    if command -v lsof &> /dev/null; then
        echo "Port is being used by:"
        lsof -i :"${port}"
    fi
    exit 1
  fi

  # --- Execution ---
  echo "Terminating any existing Foxglove bridge instances..."
  # Use pkill to find and kill processes matching the launch file name
  pkill -f "foxglove_bridge_launch.xml" > /dev/null 2>&1 || true # '|| true' prevents exit on no-match

  echo "Launching Foxglove bridge on port ${port}..."
  # Launch the bridge in the background
  ros2 launch foxglove_bridge foxglove_bridge_launch.xml \
    send_buffer_limit:=1000000000 \
    port:="${port}" \
    "${ros_args[@]}" &

  # Capture the PID of the last background command
  BRIDGE_PID=$!

  echo "Foxglove bridge started with PID: ${BRIDGE_PID}."
  # Add a small delay to ensure the server starts before the client tries to connect
  sleep 1 

  echo "Launching lichtblick..."
  # Launch the client application 
  lichtblick "lichtblick://open?ds=foxglove-websocket&ds.url=ws://localhost:${port}/"

  echo "Bridge is running. Press Ctrl+C to stop."
  # Wait for the bridge process to terminate. This keeps the script alive.
  # When the user presses Ctrl+C, the trap will trigger the cleanup function.
  wait "$BRIDGE_PID"
}

# --- Script Entrypoint ---
# Set a trap to call the cleanup function on script exit or interruption
trap cleanup EXIT
# Run the main function, passing all script arguments
main "$@"
